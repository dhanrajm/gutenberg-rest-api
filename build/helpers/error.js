import httpStatus from "http-status";
// import config from "../config";
/**
 * Intercept unhandled promise rejection and thow the same exception
 * This will be intercepted in the uncaughtException handler
 */
process.on("unhandledRejection", (reason, p) => {
    console.log("Unhandled Rejection at: Promise", p);
    throw new Error(`Unhandled promise rejection, ${reason}`);
});
/**
 * Intercept uncaughtException.
 * We are not handling any exit process. So just exit.
 * Other wise we could have called another function to do clean up and then exit
 */
process.on("uncaughtException", (err) => {
    console.log(`uncaught exception: ${err}`);
    console.log("Application encountered a critical error. Exiting");
    process.exit(1);
});
/**
 * Class representing an API error.
 * @extends Error
 */
class APIError extends Error {
    status;
    isPublic;
    /**
     * Creates an API error.
     * @param {string} message - Error message.
     * @param {number} status - HTTP status code of error.
     * @param {boolean} isPublic - Whether the message should be visible to user or not.
     */
    constructor(message, status = httpStatus.INTERNAL_SERVER_ERROR, isPublic = false) {
        super(message);
        this.name = this.constructor.name;
        this.message = message;
        this.status = status;
        this.isPublic = isPublic;
        Error.captureStackTrace(this, this.constructor);
    }
}
function errorFormatter(err, _req, _res, next) {
    console.log("errorFormatter", err.constructor.name);
    // if (err) {
    //   // validation error contains errors which is an array of error each containing message[]
    //   const unifiedErrorMessage = err.details.body
    //     .map((error: { message: string }) => error.message)
    //     .join(" and ");
    //   const error = new APIError(unifiedErrorMessage, err.statusCode, true);
    //   return next(error);
    // }
    // if (!(err instanceof APIError)) {
    //   const apiError = new APIError(err.message, err.status, err.isPublic);
    //   return next(apiError);
    // }
    return next(err);
}
function notFoundHandler(_req, _res, next) {
    const err = new APIError("API not found", httpStatus.NOT_FOUND);
    return next(err);
}
function errorHandler(err, _req, res, _next) {
    console.log(err);
    res.send("error");
    // res.status(err.status).json({
    //   message: err.isPublic ? err.message : httpStatus[err.status],
    //   stack: config.server.env === "development" ? err.stack : {},
    // });
}
export { APIError, notFoundHandler, errorFormatter, errorHandler };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaGVscGVycy9lcnJvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLFVBQVUsTUFBTSxhQUFhLENBQUM7QUFDckMsa0NBQWtDO0FBRWxDOzs7R0FHRztBQUNILE9BQU8sQ0FBQyxFQUFFLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDN0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQ0FBaUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNsRCxNQUFNLElBQUksS0FBSyxDQUFDLGdDQUFnQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQzVELENBQUMsQ0FBQyxDQUFDO0FBRUg7Ozs7R0FJRztBQUNILE9BQU8sQ0FBQyxFQUFFLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRTtJQUN0QyxPQUFPLENBQUMsR0FBRyxDQUFDLHVCQUF1QixHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsbURBQW1ELENBQUMsQ0FBQztJQUNqRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxDQUFDO0FBRUg7OztHQUdHO0FBQ0gsTUFBTSxRQUFTLFNBQVEsS0FBSztJQUMxQixNQUFNLENBQVM7SUFDZixRQUFRLENBQVU7SUFDbEI7Ozs7O09BS0c7SUFDSCxZQUNFLE9BQWUsRUFDZixTQUFpQixVQUFVLENBQUMscUJBQXFCLEVBQ2pELFdBQW9CLEtBQUs7UUFFekIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2YsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztRQUNsQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixLQUFLLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNsRCxDQUFDO0NBQ0Y7QUFFRCxTQUFTLGNBQWMsQ0FDckIsR0FBUSxFQUNSLElBQWEsRUFDYixJQUFjLEVBQ2QsSUFBa0I7SUFFbEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BELGFBQWE7SUFDYiw2RkFBNkY7SUFDN0YsaURBQWlEO0lBQ2pELDBEQUEwRDtJQUMxRCxzQkFBc0I7SUFDdEIsMkVBQTJFO0lBQzNFLHdCQUF3QjtJQUN4QixJQUFJO0lBRUosb0NBQW9DO0lBQ3BDLDBFQUEwRTtJQUMxRSwyQkFBMkI7SUFDM0IsSUFBSTtJQUVKLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ25CLENBQUM7QUFFRCxTQUFTLGVBQWUsQ0FBQyxJQUFhLEVBQUUsSUFBYyxFQUFFLElBQWtCO0lBQ3hFLE1BQU0sR0FBRyxHQUFHLElBQUksUUFBUSxDQUFDLGVBQWUsRUFBRSxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDaEUsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbkIsQ0FBQztBQUVELFNBQVMsWUFBWSxDQUNuQixHQUFRLEVBQ1IsSUFBYSxFQUNiLEdBQWEsRUFDYixLQUFtQjtJQUVuQixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbEIsZ0NBQWdDO0lBQ2hDLGtFQUFrRTtJQUNsRSxpRUFBaUU7SUFDakUsTUFBTTtBQUNSLENBQUM7QUFDRCxPQUFPLEVBQUUsUUFBUSxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsWUFBWSxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0RnVuY3Rpb24sIFJlcXVlc3QsIFJlc3BvbnNlIH0gZnJvbSBcImV4cHJlc3NcIjtcclxuaW1wb3J0IGh0dHBTdGF0dXMgZnJvbSBcImh0dHAtc3RhdHVzXCI7XHJcbi8vIGltcG9ydCBjb25maWcgZnJvbSBcIi4uL2NvbmZpZ1wiO1xyXG5cclxuLyoqXHJcbiAqIEludGVyY2VwdCB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24gYW5kIHRob3cgdGhlIHNhbWUgZXhjZXB0aW9uXHJcbiAqIFRoaXMgd2lsbCBiZSBpbnRlcmNlcHRlZCBpbiB0aGUgdW5jYXVnaHRFeGNlcHRpb24gaGFuZGxlclxyXG4gKi9cclxucHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLCAocmVhc29uLCBwKSA9PiB7XHJcbiAgY29uc29sZS5sb2coXCJVbmhhbmRsZWQgUmVqZWN0aW9uIGF0OiBQcm9taXNlXCIsIHApO1xyXG4gIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uLCAke3JlYXNvbn1gKTtcclxufSk7XHJcblxyXG4vKipcclxuICogSW50ZXJjZXB0IHVuY2F1Z2h0RXhjZXB0aW9uLlxyXG4gKiBXZSBhcmUgbm90IGhhbmRsaW5nIGFueSBleGl0IHByb2Nlc3MuIFNvIGp1c3QgZXhpdC5cclxuICogT3RoZXIgd2lzZSB3ZSBjb3VsZCBoYXZlIGNhbGxlZCBhbm90aGVyIGZ1bmN0aW9uIHRvIGRvIGNsZWFuIHVwIGFuZCB0aGVuIGV4aXRcclxuICovXHJcbnByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCAoZXJyKSA9PiB7XHJcbiAgY29uc29sZS5sb2coYHVuY2F1Z2h0IGV4Y2VwdGlvbjogJHtlcnJ9YCk7XHJcbiAgY29uc29sZS5sb2coXCJBcHBsaWNhdGlvbiBlbmNvdW50ZXJlZCBhIGNyaXRpY2FsIGVycm9yLiBFeGl0aW5nXCIpO1xyXG4gIHByb2Nlc3MuZXhpdCgxKTtcclxufSk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIEFQSSBlcnJvci5cclxuICogQGV4dGVuZHMgRXJyb3JcclxuICovXHJcbmNsYXNzIEFQSUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIHN0YXR1czogbnVtYmVyO1xyXG4gIGlzUHVibGljOiBib29sZWFuO1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gQVBJIGVycm9yLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzIC0gSFRUUCBzdGF0dXMgY29kZSBvZiBlcnJvci5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUHVibGljIC0gV2hldGhlciB0aGUgbWVzc2FnZSBzaG91bGQgYmUgdmlzaWJsZSB0byB1c2VyIG9yIG5vdC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIG1lc3NhZ2U6IHN0cmluZyxcclxuICAgIHN0YXR1czogbnVtYmVyID0gaHR0cFN0YXR1cy5JTlRFUk5BTF9TRVJWRVJfRVJST1IsXHJcbiAgICBpc1B1YmxpYzogYm9vbGVhbiA9IGZhbHNlXHJcbiAgKSB7XHJcbiAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcclxuICAgIHRoaXMuaXNQdWJsaWMgPSBpc1B1YmxpYztcclxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3JGb3JtYXR0ZXIoXHJcbiAgZXJyOiBhbnksXHJcbiAgX3JlcTogUmVxdWVzdCxcclxuICBfcmVzOiBSZXNwb25zZSxcclxuICBuZXh0OiBOZXh0RnVuY3Rpb25cclxuKSB7XHJcbiAgY29uc29sZS5sb2coXCJlcnJvckZvcm1hdHRlclwiLCBlcnIuY29uc3RydWN0b3IubmFtZSk7XHJcbiAgLy8gaWYgKGVycikge1xyXG4gIC8vICAgLy8gdmFsaWRhdGlvbiBlcnJvciBjb250YWlucyBlcnJvcnMgd2hpY2ggaXMgYW4gYXJyYXkgb2YgZXJyb3IgZWFjaCBjb250YWluaW5nIG1lc3NhZ2VbXVxyXG4gIC8vICAgY29uc3QgdW5pZmllZEVycm9yTWVzc2FnZSA9IGVyci5kZXRhaWxzLmJvZHlcclxuICAvLyAgICAgLm1hcCgoZXJyb3I6IHsgbWVzc2FnZTogc3RyaW5nIH0pID0+IGVycm9yLm1lc3NhZ2UpXHJcbiAgLy8gICAgIC5qb2luKFwiIGFuZCBcIik7XHJcbiAgLy8gICBjb25zdCBlcnJvciA9IG5ldyBBUElFcnJvcih1bmlmaWVkRXJyb3JNZXNzYWdlLCBlcnIuc3RhdHVzQ29kZSwgdHJ1ZSk7XHJcbiAgLy8gICByZXR1cm4gbmV4dChlcnJvcik7XHJcbiAgLy8gfVxyXG5cclxuICAvLyBpZiAoIShlcnIgaW5zdGFuY2VvZiBBUElFcnJvcikpIHtcclxuICAvLyAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEFQSUVycm9yKGVyci5tZXNzYWdlLCBlcnIuc3RhdHVzLCBlcnIuaXNQdWJsaWMpO1xyXG4gIC8vICAgcmV0dXJuIG5leHQoYXBpRXJyb3IpO1xyXG4gIC8vIH1cclxuXHJcbiAgcmV0dXJuIG5leHQoZXJyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbm90Rm91bmRIYW5kbGVyKF9yZXE6IFJlcXVlc3QsIF9yZXM6IFJlc3BvbnNlLCBuZXh0OiBOZXh0RnVuY3Rpb24pIHtcclxuICBjb25zdCBlcnIgPSBuZXcgQVBJRXJyb3IoXCJBUEkgbm90IGZvdW5kXCIsIGh0dHBTdGF0dXMuTk9UX0ZPVU5EKTtcclxuICByZXR1cm4gbmV4dChlcnIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlcnJvckhhbmRsZXIoXHJcbiAgZXJyOiBhbnksXHJcbiAgX3JlcTogUmVxdWVzdCxcclxuICByZXM6IFJlc3BvbnNlLFxyXG4gIF9uZXh0OiBOZXh0RnVuY3Rpb25cclxuKSB7XHJcbiAgY29uc29sZS5sb2coZXJyKTtcclxuICByZXMuc2VuZChcImVycm9yXCIpO1xyXG4gIC8vIHJlcy5zdGF0dXMoZXJyLnN0YXR1cykuanNvbih7XHJcbiAgLy8gICBtZXNzYWdlOiBlcnIuaXNQdWJsaWMgPyBlcnIubWVzc2FnZSA6IGh0dHBTdGF0dXNbZXJyLnN0YXR1c10sXHJcbiAgLy8gICBzdGFjazogY29uZmlnLnNlcnZlci5lbnYgPT09IFwiZGV2ZWxvcG1lbnRcIiA/IGVyci5zdGFjayA6IHt9LFxyXG4gIC8vIH0pO1xyXG59XHJcbmV4cG9ydCB7IEFQSUVycm9yLCBub3RGb3VuZEhhbmRsZXIsIGVycm9yRm9ybWF0dGVyLCBlcnJvckhhbmRsZXIgfTtcclxuIl19